### Goals
 There's kind of two possible goals someone searching for "cancelling" or "short-circuiting" might have:

1. Cancelling a fetch or some online/network request **inflight**, to prevent results from being returned and possibly to reduce server load (like if it's a computation-heavy request)
2. Simply **exiting out** of the async function to prevent further client-side computation, perhaps because another instance of the same async function has been called and should override the previous, or some other reason that makes the rest of the computation unnecessary

The accepted answer already covers **#1**, but I suspect many people stumbling upon this post will also be looking for **#2**, so I thought I'd share my solution.

### Reference/tutorial

https://dev.to/chromiumdev/cancellable-async-functions-in-javascript-5gp7

### General Solution

Convert your `async` function to a [generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators).

In (very) laymen's terms, a generator is a function that runs in steps, and returns the next `yield` in line each time you call it.

This helps in that you can break your function into discrete parts (demarcated by `yields`), which get exposed to an external function that can run them one by one, and decide to cancel in-between if desired.

**Our `async` function converted to a generator:**

```javascript
function* generator(input1, input2) {
  // some asynchronous things, cancellable in-between them
  const response = yield someNetworkFetch(input1);
  const data = yield response.json();

  // some synchronous things, NOT cancellable in-between them
  let value = 0;
  value += 1;
  value -= 1;

  // some synchronous things, cancellable in-between them
  value += yield someCalculation(input2);
  value += yield anotherCalculation(value);

  // return final result, combining anything you want from above
  return data.someValue + value;
}
```

**A wrapper function that allows cancelling in-between steps:**

```javascript
function wrapper() {
  let resumeValue;

  // some loop
  for (;;) {
    // synchronous check to see if we should stop processing
    // perhaps this should be a check if this is the latest call to wrapper()
    if (shouldWeCancel) {
      // handle cancel. perhaps console.log a message
      break;
    }
    const { done, value } = generator.next(resumeValue);
    if (done) {
      // process final results of generator function
      break;
    }
    // otherwise, go up to next yield statement, and process as a Promise, even if it's not an await or other asynchronous action
    resumeValue = await Promise.resolve(value);
  }
```

If you understand what the above is doing, you might notice that it's essentially the same as doing something like this:

```javascript
async function someFunction(input1, input2) {
  if (shouldWeCancel) return;
  const response = await someNetworkFetch(input1);
  if (shouldWeCancel) return;
  const data = await response.json();
  if (shouldWeCancel) return;
  let value = 0;
  value += await someCalculation(input2);
  if (shouldWeCancel) return;
  value += await anotherCalculation(value);
  if (shouldWeCancel) return;
  return data.someValue + value;
}
```

But hopefully you can see how this is more error-prone, more repetitive, and less flexible than the general solution.

### Addendum

I used this methodology in a recent project, and extended it to include the following functionality:

1. Included [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) for aborting in-flight `fetch`'s
2. Incorporated it into an [action creator](https://redux-toolkit.js.org/api/createaction/) for [`redux`](https://redux.js.org/) such that new actions cancel and override any old actions of the same action type
3. It dispatches actions to update the status of the request, similar to [this `redux-thunk-actions` library](https://github.com/machadogj/redux-thunk-actions)

### Conclusion

It's not the greatest solution in the world, but I found it to be better than using some third-party library or special transpiler-plugin. It would've been nice if a way to short-circuit `async` functions [had been built into the spec](https://github.com/tc39/ecmascript-asyncawait/issues/27), but it wasn't.
